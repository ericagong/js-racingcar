# 📄 Step1 개요

콘솔에서 동작하는 자동차 경주 게임을 구현한다.

# 📍 Step1 목표

0. 결과만큼 과정이 중요함을 명심하며, 제대로 고민한다.
1. 내가 정의한 TDD cycle을 적용하며, 문제점을 찾아본다.
2. 간단한 핵심 기능부터 순차적으로 복잡도를 높이며 디테일을 잡는다.
3. 의존성을 고려하며 테스트 코드를 작성한다.

# 🎯 구현 방향 정리

💡 `가장 작은 버전 핵심 기능` 구현 ➡️ `복잡성, 디테일 추가`하며 확장
💡 핵심 기능 분리 시, `UI 로직`과 `도메인 로직` 분리하기
💡 확장성을 고려하기 위해 `요구사항 변경 가능 지점` 체크해두기

# 1️⃣ [Phase1] 가장 작은 버전 핵심 기능 🚗

```
가장 작은 버전: 자동차 한 대
핵심 기능:
	[feature1] 사용자가 입력한 값을 자동차명으로 설정한다.
	[feature2] 자동차는 4 이상이면 전진하고, 아니면 현재 위치를 유지한다.
	[feature3] 자동차의 현재 상황 정보를 반환한다.
	[feature4] 총 5라운드를 반복하고, 우승 자동차 정보를 반환한다.
	[feature5] 반환된 정보를 콘솔에 출력한다.
```

## 🚗 기능 분리 및 구체화/시뮬레이션

### [feature1] 사용자가 입력한 값을 자동차명으로 설정한다.

[X] 자동차 이름은 `5자 이하`만 가능하다.
[X] 사용자가 잘못된 입력 값(빈 값)을 작성한 경우 프로그램을 종료한다.

### [feature2] 자동차는 4 이상이면 전진하고, 아니면 현재 위치를 유지한다.

[X] 자동차에 이름을 부여할 수 있다.  
[X] 자동차에 현재 위치를 부여할 수 있다.
[X] 전진하는 조건은 `0에서 9 사이에서 무작위 값을 구한 후 무작위 값이 4 이상일 경우`이다.

### [feature3] 자동차의 현재 상황 정보를 반환한다.

[X] 자동차 이름을 반환한다.
[X] 자동차 현재 위치를 반환한다.

### [feature4] 총 5라운드를 반복하고, 우승 자동차 정보를 반환한다.

[X] 자동차 경주는 `5회`로 고정하여 진행한다.
[X] 자동차 경주 게임을 완료한 후 누가 우승했는지를 베열로 반환한다.

### [feature5] 반환된 정보를 콘솔에 출력한다.

[X] 전진하는 자동차를 출력할 때, 자동차 이름을 같이 출력한다.

## 🧑🏻‍💻 기능 구현 순서 지정

💡 기준을 고려하며 순서를 지정한다.
**[선택 기준]**
✅ 해당 기능 구현 시, 향후 구현이 더 편해지는가?
✅ 해당 기능 구현 시, 1의 문장 상태에 더 가까워지는가?

💡 되도록이면 `도메인 로직` 관련 기능을 우선 구현하고, 이후 `UI 로직` 연관 기능을 구현한다.
[feature2] -> [feature3] -> [feature4] -> [feature5] -> [feature1]

# 2️⃣ [Phase2] 🚗🚗🚗 확장 기능

```
확장 버전: 자동차 여러 대
핵심 기능:
	[feature1] 사용자 입력이 유효하지 않은 경우, 오류 발생하고 프로그램을 종료시킨다.
	[feature2] 유효한 자동차 이름인 경우, 게임을 시작하여 총 5라운드를 진행한다.
	[feature3] 게임이 종료되면, 각 라운드 스냅샷 및 우승자 정보를 반환한다.
```

## 🚗 기능 분리 및 구체화/시뮬레이션

💡 `가장 작은 버전 핵심 기능` 구현 ➡️ `복잡성, 디테일 추가`하며 확장하는 과정에서 추가 구현해야 하는 부분만 정리

### [feature1] 사용자 입력이 유효하지 않은 경우, 오류 발생하고 프로그램을 종료시킨다.

- 사용자 입력이 잘못된 경우
  [X] 사용자 입력이 빈 값인 경우, 오류를 발생시킨다.
- 자동차 이름이 잘못된 경우
  [X] 자동차 이름 중 중복된 이름이 있는 경우, 오류를 발생시킨다.
  [X] 자동차 이름 중 빈 값이 있는 경우, 오류를 발생시킨다.

### [feature2] 유효한 자동차 이름인 경우, 게임을 시작하여 총 5라운드를 진행한다.

[X] Phase1에서 구현 완료.

### [feature3] 게임이 종료되면, 각 라운드 스냅샷 및 우승자 정보를 반환한다.

[X] 우승자가 여러 명인 경우, `,`로 구분하여 출력한다.

## 🧑🏻‍💻 기능 구현 순서 지정

💡 기준을 고려하며 순서를 지정한다.
**[선택 기준]**
✅ 해당 기능 구현 시, 향후 구현이 더 편해지는가?
✅ 해당 기능 구현 시, 1의 문장 상태에 더 가까워지는가?

💡 되도록이면 `도메인 로직` 관련 기능을 우선 구현하고, 이후 `UI 로직` 연관 기능을 구현한다.
[feature1] -> [feature3]

# ✅ Step1 제출 전 체크 사항

## 🎯 기능 요구 사항

[X] 자동차에 이름을 부여할 수 있다.
[X] 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다.
[X] 자동차 이름은 쉼표(,)를 기준으로 구분하며 이름은 5자 이하만 가능하다.
[X] 자동차 경주는 5회로 고정하여 진행한다.
[X] 전진하는 조건은 0에서 9 사이에서 무작위 값을 구한 후 무작위 값이 4 이상일 경우이다.
[X] 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한 명 이상일 수 있다.
[X] 우승자가 여러 명일 경우 쉼표(,)를 이용하여 구분한다.
[X] 사용자가 잘못된 입력 값을 작성한 경우 프로그램을 종료한다.

## 🎯 프로그래밍 요구사항

[X][코드 스타일 가이드](https://github.com/woowacourse/woowacourse-docs/tree/main/styleguide/javascript)에 따라 컨벤션을 준수하며 개발한다.
[X] 변수 선언시 var를 사용하지 않는다. let, const를 사용한다.
[X] 전역 변수를 만들지 않는다.
[V] 축약하지 않는다.
[X] 하드 코딩된 값 대신에 의미 있는 상수를 활용한다.
[X] 동등 연산자는 === 로만 사용한다.
[X] else 예약어를 쓰지 않는다.
[X] 함수(또는 메서드)의 길이가 10라인을 넘어가지 않도록 구현한다.
[X] 함수(또는 메서드)가 한 가지 일만 하도록 만든다.
[X] 함수(또는 메서드)의 들여쓰기 depth는 2단계까지만 허용한다.
[X] 도메인 로직과 UI 로직을 분리한다.
[X] 모든 도메인 로직에 단위 테스트를 구현한다. (UI 로직은 제외)

# 🔧 리팩토링

💡 `가독성`, `재사용성`, `성능`을 고려하며 리팩토링

## 유지보수 편의성을 고려하여 MVC 패턴으로 코드 리팩토링

- Model : Car, Game
- Controller: GameController
- View: View
- MVC 리팩토링 체크 사항
  [X] Model은 Controller와 View에 의존하지 않음
  [X] View는 Model에만 의존하고, Controller에 의존해서는 안됨.
  [X] View가 Model로부터 데이터를 받을 때는, 사용자마다 다르게 보여줘야하는 데이터에 한함.
  [X] View가 Model로부터 데이터를 받을 때는 항상 Controller를 거쳐야 함.
  [X] Controller는 Model과 View에 의존해도 됨.

## 피드백 검토 및 반영 사항

### step1 질의 응답 기반 반영 사항

1. 비동기 입력 처리 코드
   [ ] callback에서 async/await 으로 변경

2. 클래스 필요성
   [ ] Controller, View 클래스 -> 일반 객체로 변경
   [ ] Controller, View 모듈화

3. 테스트
   [ ] 테스트케이스 자동 생성 코드 제거

### step1 피드백 기반 반영 사항

1. 상수 처리
   [X] Model 내부로 상수 위치 변경
   [X] 상수가 클래스와 결합해야하면 `static` 키워드 사용
   [ ] 클래스 내부 상태 은닉 필요하면 `private` 접근 제어자 사용

2. 요구사항 변경 가능지점 체크하여 확장성 고려해 코드 작성
   [ ] 자동차 전진 조건이 변경되는 경우

### 공통 피드백 기반 반영 사항

1.  가독성

- 코딩 컨벤션 변경
  [ ] 클래스 내 변수/메소드 구현 순서 통일: 상수 -> 클래스 변수 -> 인스턴스 변수 -> 생성자 -> 메서드
  [ ] 개행 방식 통일
  [ ] import문 순서 규칙에 따라 통일
  [ ] eslint, prettier 환경 설정 도입
- 의미가 드러나도록 코드 작성하기
  [ ] 최대한 주석 없애기
  [ ] 의미가 드러날 수 있도록 변수/함수명 지정
  [ ] 코드만 봐도 충분히 의미를 파악할 수 있게 단순 명료하게 작성
- 함수/메소드는 하나의 역할만 담당하도록 처리
  [ ] 입력값 검증과 예외 생성 함수 분리
- 함수/메소드를 최대한 간단하게 작성
  [ ] 함수의 인자 수는 3개 미만으로 유지. 그 이상으로 필요하다면 함수/메소드를 분리하거나 객체 형태로 인자 처리
  [ ] 함수 depth 2 이상 지양하기. 그 이상으로 필요하다면 함수/메소드를 분리
  [ ] early return 사용하기. 예외 케이스는 함수/메소드 앞부분 위치
  [ ] boolean값만 리턴하는 함수는 조건문 없이 처리

2.  재사용성

- JS 빌트인 객체 내장메서드 최대한 활용
  [ ] for, while 반복문 대신 Array 객체 내장 메서드 사용
- 명령형보다는 선언형 코드 작성

3.  테스트
    [ ] 테스트를 위한 코드는 프로덕션 코드에서 분리
    [ ] 단위 테스트 실패 이유는 하나!
    [ ] 경계조건 테스트에 parameterized test 방식 사용
